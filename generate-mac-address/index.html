{#header.html#}

{%title=Generate MAC Address — u00 Network Tools%}
{%description=Generate valid MAC addresses for testing, virtualization, and documentation. Control unicast/multicast and locally administered bits.%}

<style>

    /* Common input styles */
    .input-field {
        font-family: 'Consolas', 'Courier New', Courier, monospace;
        font-size: 24px;
        width: 250px;
        height: 40px;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 0 8px;
    }

    .input-label {
        font-weight: bold;
        font-size: 16px;
    }

    /* Checkbox container styles */
    .checkbox-container {
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: center;
        padding: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
    }

    .checkbox-row {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .checkbox-row label {
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
    }

    input[type="checkbox"] {
        width: 20px;
        height: 20px;
        cursor: pointer;
    }

    .btn-download {
        padding: 12px 20px;
        background-color: #28a745;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: background-color 0.3s ease;
        margin-top: 8px;
    }

    .btn-download:hover {
        background-color: #218838;
    }
</style>

<h1>Generate MAC Address</h1>
<p>
    Generate valid MAC addresses with explicit control over unicast/multicast and locally administered bits.
    Designed for testing, virtualization, and documentation.
</p>

<script>
    // Page-specific functions for MAC address generation
    var error = '';
    var macAddress = '';
    var generatedAddresses = [];
    var lastValidPrefix = '';

    function getRandomHexDigit() {
        return Math.floor(Math.random() * 16).toString(16).toUpperCase();
    }

    function validatePrefixInput() {
        var prefixInput = document.getElementById('prefix');
        var inputValue = prefixInput.value;
        var prefixMessage = document.getElementById('prefix_message');

        // Check for invalid characters
        var invalidChars = inputValue.match(/[^A-Fa-f0-9:]/g);
        if (invalidChars) {
            prefixMessage.textContent = 'Invalid characters: only hex digits (0-9, A-F) and colons (:) are allowed.';
            prefixMessage.style.color = '#dc3545';
            prefixInput.style.borderColor = '#dc3545';
            return false;
        }

        // Clean the input (remove colons and convert to uppercase)
        var cleanPrefix = inputValue.replace(/:/g, '').toUpperCase();

        // Check length
        if (cleanPrefix.length > 11) {
            prefixMessage.textContent = 'Prefix too long. Maximum 11 hex digits (5.5 bytes) allowed.';
            prefixMessage.style.color = '#dc3545';
            prefixInput.style.borderColor = '#dc3545';
            return false;
        }

        // Show info message if input is valid
        prefixMessage.textContent = 'First byte will be normalized according to selected bit options.';
        prefixMessage.style.color = '#666';
        prefixInput.style.borderColor = '#ccc';

        // Check if prefix actually changed
        var cleanPrefix = inputValue.replace(/:/g, '').toUpperCase();
        if (cleanPrefix !== lastValidPrefix) {
            lastValidPrefix = cleanPrefix;
            // Generate new MAC address only if prefix changed
            setTimeout(function () {
                generateMacAddress();
            }, 100);
        }

        return true;
    }

    function parsePrefix() {
        var prefixInput = document.getElementById('prefix').value;

        // Validate input first
        if (!validatePrefixInput()) {
            return null;
        }

        // Clean and return the prefix
        var prefix = prefixInput.replace(/[^A-Fa-f0-9]/g, '').toUpperCase();
        console.log('Parsed prefix:', prefix);

        return prefix;
    }

    function clearPrefixInput() {
        var inputElement = document.getElementById('prefix');
        var prefixMessage = document.getElementById('prefix_message');

        inputElement.value = '';
        inputElement.style.borderColor = '#ccc';
        prefixMessage.textContent = 'First byte will be normalized according to selected bit options.';
        prefixMessage.style.color = '#666';

        // Also clear the main error message
        document.getElementById('error_message').textContent = '';

        // Reset last valid prefix and regenerate
        lastValidPrefix = '';
        generateMacAddress();
    }

    function generateMacAddress() {
        var prefix = parsePrefix();
        if (prefix === null) {
            return;
        }
        macAddress = prefix;

        // Generate random hex digits to complete the MAC address
        while (macAddress.length < 12) {
            macAddress += getRandomHexDigit();
        }

        // Apply locally administered bit to the first octet
        // Ensure we have at least 2 characters for the first octet
        var firstOctetHex = macAddress.substr(0, 2);
        if (firstOctetHex.length === 1) {
            firstOctetHex = firstOctetHex + '0';
        }
        var firstOctet = parseInt(firstOctetHex, 16);

        // Bit 0 (LSB) of first octet: always 0 for unicast
        firstOctet &= 0xFE; // Clear bit 0 to ensure unicast

        // Bit 1 of first octet: 1 = locally administered, 0 = universally administered
        var isLocallyAdministered = document.getElementById('locally_administered_checkbox').checked;
        if (isLocallyAdministered) {
            firstOctet |= 0x02; // Set bit 1
        } else {
            firstOctet &= 0xFD; // Clear bit 1
        }

        // Replace first octet in MAC address (always upper case)
        var newFirstOctet = firstOctet.toString(16).toUpperCase().padStart(2, '0');
        macAddress = newFirstOctet + macAddress.substr(2);

        // Format the MAC address as XX:XX:XX:XX:XX:XX
        var formattedMac = '';
        for (var i = 0; i < 12; i += 2) {
            formattedMac += macAddress.substr(i, 2);
            if (i < 10) {
                formattedMac += ':';
            }
        }
        document.getElementById('mac_address').value = formattedMac;
        document.getElementById('error_message').textContent = '';

        // Generate 100 unique addresses
        generate100UniqueAddresses();
    }

    function generateSingleMacAddress() {
        var prefix = parsePrefix();
        if (prefix === null) {
            return null;
        }
        var singleMacAddress = prefix;

        // Generate random hex digits to complete the MAC address
        while (singleMacAddress.length < 12) {
            singleMacAddress += getRandomHexDigit();
        }

        // Apply multicast and locally administered bits to the first octet
        var firstOctetHex = singleMacAddress.substr(0, 2);
        if (firstOctetHex.length === 1) {
            firstOctetHex = firstOctetHex + '0';
        }
        var firstOctet = parseInt(firstOctetHex, 16);

        // Always ensure unicast (bit 0 = 0)
        firstOctet &= 0xFE;

        var isLocallyAdministered = document.getElementById('locally_administered_checkbox').checked;
        if (isLocallyAdministered) {
            firstOctet |= 0x02;
        } else {
            firstOctet &= 0xFD;
        }

        var newFirstOctet = firstOctet.toString(16).toUpperCase().padStart(2, '0');
        singleMacAddress = newFirstOctet + singleMacAddress.substr(2);

        // Format as XX:XX:XX:XX:XX:XX
        var formatted = '';
        for (var i = 0; i < 12; i += 2) {
            formatted += singleMacAddress.substr(i, 2);
            if (i < 10) {
                formatted += ':';
            }
        }
        return formatted;
    }

    function generate100UniqueAddresses() {
        generatedAddresses = [];
        var addressSet = new Set();

        // Check if we have enough random space for 100 unique addresses
        var prefix = parsePrefix();
        if (prefix === null) {
            return;
        }

        var randomDigits = 12 - prefix.length;
        var maxPossibleAddresses = Math.pow(16, randomDigits);
        var targetCount = Math.min(100, maxPossibleAddresses);

        if (maxPossibleAddresses < 100) {
            console.warn('With prefix length', prefix.length, 'can only generate', maxPossibleAddresses, 'unique addresses');
        }

        // Add the main generated address
        var mainAddress = document.getElementById('mac_address').value;
        if (mainAddress) {
            addressSet.add(mainAddress);
            generatedAddresses.push(mainAddress);
        }

        // Generate additional unique addresses with safety limit
        var attempts = 0;
        var maxAttempts = targetCount * 10; // Safety limit to prevent infinite loops

        while (generatedAddresses.length < targetCount && attempts < maxAttempts) {
            var newAddress = generateSingleMacAddress();
            attempts++;

            if (newAddress && !addressSet.has(newAddress)) {
                addressSet.add(newAddress);
                generatedAddresses.push(newAddress);
            }
        }

        console.log('Generated', generatedAddresses.length, 'unique MAC addresses out of', targetCount, 'target (', attempts, 'attempts)');

        // Update download button text
        var downloadButton = document.getElementById('download_button');
        if (downloadButton) {
            downloadButton.textContent = 'Download ' + generatedAddresses.length + ' MAC Addresses (CSV)';
        }
    }

    function downloadCSV() {
        if (generatedAddresses.length === 0) {
            alert('No MAC addresses generated. Please generate a MAC address first.');
            return;
        }

        var csvContent = generatedAddresses.join('\n');
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var link = document.createElement('a');

        if (link.download !== undefined) {
            var url = URL.createObjectURL(blob);
            link.setAttribute('href', url);

            // Dynamic filename with count
            var filename = 'mac_addresses_' + generatedAddresses.length + '.csv';
            link.setAttribute('download', filename);

            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            alert('Downloaded ' + generatedAddresses.length + ' MAC addresses to ' + filename);
        }
    }

</script>

<div style="display: flex; flex-direction: column; gap: 12px; align-items: center; margin-top: 12px;">
    <div style="display: flex; flex-direction: column; gap: 6px; align-items: center;">
        <label for="prefix" class="input-label">Prefix</label>
        <div style="display: flex; flex-direction: row; gap: 0; align-items: center;">
            <input type="text" id="prefix" class="input-field" placeholder="e.g. 02:AB:CD or 02ABCD"
                oninput="validatePrefixInput()" />
            <button id="clear_prefix_button" class="btn-clear" onclick="clearPrefixInput()">
                <!-- SVG will be inserted by JavaScript -->
            </button>
        </div>
        <div id="prefix_message"
            style="font-size: 12px; color: #666; text-align: center; max-width: 300px; line-height: 1.3; min-height: 16px;">
            First byte will be normalized according to selected bit options.
        </div>
    </div>

    <div class="checkbox-container">
        <div class="checkbox-row">
            <input type="checkbox" id="locally_administered_checkbox" checked onchange="generateMacAddress()" />
            <label for="locally_administered_checkbox" class="input-label">Locally Administered (bit 1)</label>
        </div>
    </div>
    <button onclick="generateMacAddress()" class="big">Generate</button>
    <div style="display: flex; flex-direction: row; gap: 12px; align-items: center;">
        <input type="text" id="mac_address" readonly class="input-field" />
        <button id="copy_button" class="btn-copy">
            <!-- SVG will be inserted by JavaScript -->
        </button>
    </div>

    <button id="download_button" onclick="downloadCSV()" class="btn-download">
        Download MAC Addresses (CSV)
    </button>
    <div id="error_message" style="color: red; font-weight: bold; min-height: 24px;"></div>
</div>

<script>
    generateMacAddress();
    
    // Initialize copy button using header.html functions
    document.addEventListener('DOMContentLoaded', function() {
        if (typeof initializeCopyButton === 'function') {
            initializeCopyButton('copy_button', 'mac_address');
        }
        
        // Initialize clear button manually
        var clearButton = document.getElementById('clear_prefix_button');
        if (clearButton && typeof SVG_ICONS !== 'undefined') {
            clearButton.innerHTML = SVG_ICONS.clear;
        }
    });
</script>

<div>
    <h2>About this tool</h2>
    <div>
        This online tool can generate random or alternate MAC addresses, producing unique values suitable for testing
        and temporary network configuration.
    </div>

    <h2>Why generate MAC addresses</h2>

    <p>
        Generating MAC addresses is commonly required in networking and software
        development scenarios where real hardware identifiers cannot or should not
        be used.
    </p>

    <ul>
        <li>
            <strong>Network testing</strong> — creating predictable or isolated
            environments for testing switches, routers, and DHCP servers.
        </li>
        <li>
            <strong>Virtual machines and containers</strong> — assigning unique MAC
            addresses to virtual network interfaces.
        </li>
        <li>
            <strong>Emulation and simulation</strong> — modeling network behavior
            without relying on physical devices.
        </li>
        <li>
            <strong>Privacy and anonymization</strong> — using alternate MAC addresses
            to avoid exposing real hardware identifiers.
        </li>
        <li>
            <strong>Documentation and examples</strong> — providing valid but safe MAC
            addresses in technical documentation and sample configurations.
        </li>
    </ul>


    <h2>MAC address format</h2>

    <p>
        A MAC (Media Access Control) address is a <strong>48-bit identifier</strong> used to
        identify network interfaces at the data link layer (Layer 2).
        It is commonly written as six hexadecimal bytes:
    </p>

    <pre>
XX:XX:XX:XX:XX:XX
</pre>

    <p>
        Each pair of hexadecimal digits represents one byte (8 bits).
    </p>

    <h3>Special bits in the first byte</h3>

    <p>
        The two least significant bits of the first byte have special meaning:
    </p>

    <ul>
        <li>
            <strong>I/G bit (bit 0)</strong> —
            <code>0</code> indicates a unicast address,
            <code>1</code> indicates a multicast address.
        </li>
        <li>
            <strong>U/L bit (bit 1)</strong> —
            <code>0</code> indicates a globally unique (vendor-assigned) address,
            <code>1</code> indicates a locally administered address.
        </li>
    </ul>

    <h3>Locally administered MAC addresses</h3>

    <p>
        Locally administered MAC addresses are not assigned to hardware vendors.
        They are commonly used for:
    </p>

    <ul>
        <li>network testing</li>
        <li>virtual machines and containers</li>
        <li>emulation and simulation</li>
        <li>documentation and examples</li>
    </ul>

    <p>
        Such addresses avoid conflicts with real network hardware and are safe
        for temporary or test environments.
    </p>

    <h3>Unicast and multicast MAC addresses</h3>

    <p>
        MAC addresses can be classified as <strong>unicast</strong> or <strong>multicast</strong>
        based on the value of the I/G bit (the least significant bit of the first byte).
    </p>

    <h4>Unicast</h4>

    <p>
        A <strong>unicast MAC address</strong> identifies a single network interface.
        Frames sent to a unicast address are delivered to exactly one device.
    </p>

    <p>
        For unicast addresses, the I/G bit is set to <code>0</code>.
    </p>

    <p>
        Unicast MAC addresses are used in most common networking scenarios,
        including device configuration, testing, and virtual network interfaces.
    </p>

    <h4>Multicast</h4>

    <p>
        A <strong>multicast MAC address</strong> identifies a group of network interfaces.
        Frames sent to a multicast address may be received by multiple devices
        that are members of the multicast group.
    </p>

    <p>
        For multicast addresses, the I/G bit is set to <code>1</code>.
    </p>

    <p>
        Multicast MAC addresses are commonly used for protocols such as
        ARP, IPv6 Neighbor Discovery, and various discovery and streaming mechanisms.
    </p>

    <p>
        Most network testing and virtualization scenarios require
        <strong>unicast</strong> MAC addresses rather than multicast ones.
    </p>

    <h3>Organizationally Unique Identifier (OUI)</h3>

    <p>
        The first <strong>three bytes</strong> of a MAC address are known as the
        <strong>Organizationally Unique Identifier (OUI)</strong>.
        An OUI identifies the organization or vendor that assigned the address.
    </p>

    <pre>
OUI:XX:XX:XX
</pre>

    <p>
        For <strong>globally unique</strong> MAC addresses, OUIs are assigned by
        the IEEE and are used to identify hardware manufacturers.
    </p>

    <p>
        When the <strong>U/L bit</strong> is set to <code>1</code> (locally administered),
        the address is <strong>not associated with a real vendor</strong>,
        and the OUI field does not represent an IEEE-assigned manufacturer.
    </p>

    <h4>Vendor-based MAC addresses</h4>

    <p>
        Vendor-based MAC addresses use a real IEEE-assigned OUI and are typically
        found on physical network interfaces.
    </p>

    <p>
        Using real vendor OUIs in test environments may lead to address conflicts
        or unintended interaction with network equipment.
    </p>

    <h4>Locally administered addresses and OUI</h4>

    <p>
        For locally administered MAC addresses, the OUI field can be used freely
        for internal or experimental purposes.
    </p>

    <p>
        This generator produces <strong>locally administered</strong> MAC addresses,
        which ensures that generated addresses do not collide with real
        hardware vendor assignments.
    </p>


</div>

<div>
    <h3>Others</h3>
    <div>
        <div><a href="/generate-mac-address/python/">Generate MAC Addresses with Python</a></div>
        <div><a href="/generate-mac-address/golang/">Generate MAC Addresses with Go</a></div>
    </div>

</div>

{#bottom.html#}